---
title: "GIS course @ yDiv"
output:
  html_document:
    toc: true
    toc_depth: 2
    number_sections: true
    theme: united
    highlight: tango
    smart: true
    fig_width: 4
    fig_height: 4
    fig_caption: true
    df_print: paged
    code_folding: show
---

```{r utils, include=FALSE}
highlight <- function(x, pattern) {
  gsub(
    pattern,
    paste0("\033[0;41m", pattern,"\033[0m"),
    x
  )
}
```

# Introduction {.tabset}

## Set up

  - R installed
  - `terra` installed
  - `codetools` installed (optional)

## Program {.tabset}

### What we will cover

  - Two days course
  - First day: get to know geometries and rasters
  - Second day: GIS operations + individual/group project

### What to expect

  - Familiarize yourself with basic GIS data and operations
  - Start a project of your interest
  - Getting some simple figures/analyses started

### What not to expect

  - To become a world-leading GIS expert

## Lecturers {.tabset}

### Emilio Berti (TiBS)
![](figures/emilio.png)

 - Theory in Biodiversity Science
 - Macroecologist / biogeographer
 - Theoretical ecologists

### Guilherme Pinto (BioEcon)

```{r setup}
library(terra)
```

# Data Types {.tabset}

There are two main data types used in GIS:

  1. Geometries, also called vectors or shapes
  2. Rasters

They fill two different needs, namely to represent structures that can be well approximated using geometric objects, such as lines, circles, etc., 
and to represent grid data over an area.

## Geometries {.tabset}

### Overview
Structures such as a street or a building can be represented by a geometric objects.
For instance, a street can be represented by a straight line, whereas a building by a polygon.
It makes sense to store the data of these type of structures as their geometric representation.
For example, the building we are in and the adjacent street:

```{r idiv-building, class.source="fold-hide", fig.align='center'}
# This code in incomprehensible to you FOR NOW
# Just an example of geometries
r <- rast("data/idiv-building.tif")
plotRGB(r)
l <- vect(
  rbind(
    c(12.39585, 51.31866),
    c(12.39846, 51.31722)
  ),
  crs = "EPSG:4326"
)
lines(l, col = "green", lw = 5)
idiv <- vect(
  rbind(
    c(12.39573, 51.31794),
    c(12.39645, 51.31765),
    c(12.39664, 51.31812),
    c(12.39602, 51.31849),
    c(12.39573, 51.31794)
  ),
  crs = "EPSG:4326"
) |>
  as.lines() |>
  as.polygons()
idiv$name <- "iDiv building"
idiv$perimeter <- perim(idiv)
idiv$area <- expanse(idiv)
plot(idiv, add = TRUE, col = adjustcolor("blue", alpha.f = .5))
```

Geometries are saved in _vector_ or _shape_ files.
In addition to the geometric representation of the structure, 
shapefiles also contain metadata for the geometric representation, 
such as the its extent and coordinate reference system (we will talk about this later),
and for the structure, such as their name, length, etc.
For instance, the geometry of the iDiv building above is:
```{r example-geometry, class.source="fold-hide", }
idiv
```

Note that this structure has one geometry and three attributes/variables (`dimensions : 1, 3 (geometries, attributes)`): `name`, `perimeter` ($m$), and `area` ($m^2$).

### Geometry Types

In `terra`, there are three main geometry types:

  1. Points: they are defined by a vector with two values for coordinates (e.g., longitude and latitude)
  2. Lines: they are a series of points connected pairwise by straight lines
  3. Polygons: they are a series of lines inscribing a closed area

In `terra`, geometries are created with the function `vect()`.
To create a point geometry, you need to pass a matrix with the coordinates:
```{r create-point}
xy <- cbind(12.39585, 51.31866)  # cbind force it to be a matrix
vect(xy)
```
To create a geometry of multiple points, simply pass a matrix that has multiple rows:
```{r create-points}
xy <- rbind(
  cbind(12.39585, 51.31866),
  cbind(12.39584, 51.31865)
)
poi <- vect(xy)
```

In order to create lines, first create a multi-point geometry, then convert it using `as.lines()`:
```{r create-lines}
xy <- rbind(
  cbind(12.39585, 51.31866),
  cbind(12.39584, 51.31865)
)
lin <- vect(xy) |> as.lines()
```

In order to create polygons, first create a mutli-point geometry, then covert it to lines, and finally to polygons using `as.polygons()`.
The last point should be the same as the first to close the geometry.

```{r create-polygons}
xy <- rbind(
  cbind(12.39585, 51.31866),
  cbind(12.39584, 51.31865),
  cbind(12.39584, 51.31866),
  cbind(12.39585, 51.31866)
)
pol <- vect(xy) |> as.lines() |> as.polygons()
```

```{r geometries-plot, fig.align='center'}
plot(pol, col = "gold")
lines(lin, col = "red", lw = 5)
points(poi, col = "blue", cex = 1)
```

### Reading & Writing Geometries
`vect()` is also used to read geometries from a file.
For instance, to read the shapefile with the country boundary of Germany:
```{r read-shapefile, fig.align='center'}
ger <- vect("data/germany.shp")
ger
```

To write geometries to disk, use `writeVector()`.

```{r, write-shapefile, eval=FALSE}
writeVector(ger, "data/germany.shp", overwrite = TRUE)
```

## Rasters {.tabset}

### Overview

Rasters are gridded areas where each grid pixel assumes a value.
When the data we are interested in are values on a gridded area, 
rasters are a better options than to using geometries.
For example, if we want to represent landcover type over a large area(forest, agriculture, build-up, etc.),
it is easier to grid the area into pixels and save the landcover type of each pixel rather
than to create a geometry for each different structure.
```{r leipzig-landcover, class.source="fold-hide", fig.align='center', fig.width=7, fig.caption="Landcover map of Leipzig from DLR (German Aerospace Center)"}
r <- rast("data/landcover-2015.tif")
plot(r)  # from EOC of DLR
```
Rasters are saved in raster files. 
In addition to the values of each grid, rasterfiles also contain metadata for the grid, 
such as the its extent and coordinate reference system (we will talk about this later).
For instance, some of the metadata of the landcover raster:
```{r raster-metadata, class.source="fold-hide"}
r
```
Note the metadata `dimensions` (grid size), `resolution` (spatial resolution, in $m$), 
and `extent` (spatial extent).

### Creating Rasters from Scratch
Simply put, rasters are array associated spatial metadata.
In `terra`, use `rast()` to create a raster from a matrix.
```{r array, fig.align='center'}
m <- matrix(rnorm(100), nrow = 10, ncol = 10)  # 10x10 matrix
r <- rast(m)
plot(r)
```
Usually, you won't create rasters from scratch.
However, if you are familiar with R arrays, you will notice a nice properties that is inherited by rasters: rasters can have multiple layers, with each layers being a matrix.
```{r stack, fig.align='center', fig.width=8}
r <- rast(array(rnorm(200), dim = c(10, 10, 2)))
plot(r)
```
Multiple rasters can also be stacked using `c()`.
```{r stack-c, fig.align='center', fig.width=8}
r1 <- rast(matrix(rnorm(100), nrow = 10, ncol = 10))
r2 <- rast(matrix(rnorm(100), nrow = 10, ncol = 10))
r <- c(r1, r2)
plot(r)
```

### Reading & Writing Rasters
To read rasters into memory, use `rast()`.
```{r read-raster, fig.align='center'}
r <- rast("data/landcover-2015.tif")
r
```

To write rasters to disk, use `writeRaster()`.

```{r, write-raster, eval=FALSE}
writeRaster(r, "data/landcover-2015.tif", overwrite = TRUE, datatype = "INT1U")
```
Here, the argument `datatype = "INTU1"` (specifying the values in the grid are 1-byte unsigned integers) 
is needed because the rasters contains classes (levels).
In most cases, this argument is best left unspecified, as `terra` picks the optimal value by default.

## Spatial metadata {.tabset}

Spatial objects, being geometries or rasters, always need certain metadata to be useful.
For example, a raster is of little help if there is not information of the area it covers.
The most important metadata are:

  1. Spatial extent: the four corners of the quadrilateral polygon that inscribe the object represented
  2. Coordinate reference system: how is the earth surface represented
  3. Resolution (for rasters only)

We will cover each one of these three metadata in detail.

### Spatial extent
The spatial extent is the quadrilateral that inscribe the area of the spatial data.
The extent is usually represented by the coordinates of the four vertices of the quadrilateral, i.e. `xmin`, `xmax`, `ymin`, and `ymax`.
To get the spatial extent of an object, use `ext()`.
```{r ext}
r <- rast("data/landcover-2015.tif")
ext(r)
```
### Coordinate reference system

To know the CRS of an object, use `crs()`.
By default, `crs()` displays the CRS in Well Known Text (WKT) format.
WKT is not very nice for humans; use the extra argument `proj = TRUE` to see the PROJ4
format of the CRS.

```{r, crs}
crs(idiv, parse = TRUE)
crs(idiv, proj = TRUE)
```

### Resolution

Resolution applies only to rasters, as geometries are geometric representation of structure and can be scaled at any level.
To get the resolution of a raster, use `res()`.
```{r res}
r <- rast("data/landcover-2015.tif")
res(r)
```
The unit of the output of `res()` is the same as the unit of the CRS, in this case meters:
```{r unit}
crs(r, proj = TRUE)
```

## Data Conversion

### Geometries to Rasters

To convert geometries to raster, use `rasterize()`.
In addition to the geometry to rasterize, you need to pass a raster to function as template, i.e. from which extent, CRS, and resolution are extracted from.
```{r geom-to-rast}
r <- rast("data/landcover-2015.tif")
idiv <- project(idiv, crs(r))
idiv_r <- rasterize(idiv, r, touches = TRUE)
```
I specified `touches = TRUE` assign a value of 1 to all cells that are touched by the polygon.
The extent of this new raster is the same as the landcover one, which is too big to actually see the raterized polygon.
Use `trim()` to trim the raster to the smallest raster containing all values that are not `NA`.
```{r trim, fig.align='center'}
plot(trim(idiv_r))
lines(idiv)
```

### Rasters to Geometries

To convert rasters to geometries, use `as.points()` or `as.polygons()`.
```{r rast-to-geom}
r <- rast("data/landcover-2015.tif")
r <- crop(r, buffer(idiv, 1e2))  # restrict the area to something that can be plotted
poi <- as.points(r)
pol <- as.polygons(r)
```
```{r, class.source="fold-hide", fig.align='center', fig.width=10}
op <- par(no.readonly = TRUE)
par(mfrow = c(1, 2))
plot(poi, "category")
lines(idiv)
plot(pol, "category")
lines(idiv)
par(op)
```

# Reprojecting

It is quite common that data are obtained from a source that uses a CRS that is not ideal for analyses.
It is even more common that data are gathered from multiple sources that do not use the same CRS.
In such cases, the spatial data should be reprojected to one common CRS that is ideal for analyses.

In `terra`, use `project()`, which can take three types of arguments:

  1. A spatial object with known CRS
  2. A string with the WKT or PROJ4 CRS
  3. A code of a known CRS, e.g. from the EPSG standard

```{r reproject}
r <- rast("data/landcover-2015.tif")
germany <- vect("data/germany.shp")

germany <- project(germany, r)  # a spatial object
germany_mollweide <- project(germany, "+proj=moll")  # a proj4
germany_4326 <- project(germany, "EPSG:4326")  # a CRS code
```

As always, be careful, because CRS have a big influence on analyses and visualization:

```{r, class.source="fold-hide", fig.align='center', fig.width=5, fig.height=5}
plot(buffer(vect(cbind(2e6, 3e6)), 4e6), col = "white", lw = 1e-6)
polys(germany, col = "grey90")
polys(germany_mollweide, col = "grey90")
polys(germany_4326, col = "grey90")
l <- vect(
  rbind(
    cbind(5e5, 5e5),
    cbind(0, 0)
  )
)
lines(l[1], l[2], arrows = TRUE, length = .1)
l <- vect(
  rbind(
    cbind(1e6, 1e6),
    cbind(0, 0)
  )
)
text(l[1], labels = "Cannot be seen,\nbut EPSG:4326 is here")
```
