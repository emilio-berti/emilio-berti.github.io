---
title: "GIS course @ yDiv"
output:
  html_document:
    toc: true
    toc_depth: 2
    number_sections: true
    theme: united
    highlight: tango
    smart: true
    fig_width: 4
    fig_height: 4
    fig_caption: true
    df_print: paged
    code_folding: show
---

# Introduction {.tabset}

## Set up

  - R installed
  - `terra` installed
  - `codetools` installed (optional)

## Program {.tabset}

### What we will cover

  - Two days course
  - First day: get to know geometries and rasters
  - Second day: GIS operations + individual/group project

### What to expect

  - Familiarize yourself with basic GIS data and operations
  - Start a project of your interest
  - Getting some simple figures/analyses started

### What not to expect

  - To become a world-leading GIS expert

## Lecturers {.tabset}

### Emilio Berti (TiBS)
![](figures/emilio.png)

 - Theory in Biodiversity Science
 - Macroecologist / biogeographer
 - Theoretical ecologists

### Guilherme Pinto (BioEcon)

```{r setup}
library(terra)
```

# Data Types {.tabset}

There are two main data types used in GIS:

  1. Geometries, also called vectors or shapes
  2. Rasters

They fill two different needs, namely to represent structures that can be well approximated using geometric objects, such as lines, circles, etc., 
and to represent grid data over an area.

## Geometries {.tabset}

### Overview
Structures such as a street or a building can be represented by a geometric objects.
For instance, a street can be represented by a straight line, whereas a building by a polygon.
It makes sense to store the data of these type of structures as their geometric representation.
For example, the building we are in and the adjacent street:

```{r idiv-building, class.source="fold-hide", fig.align='center'}
# This code in incomprehensible to you FOR NOW
# Just an example of geometries
r <- rast("data/idiv-building.tif")
plotRGB(r)
l <- vect(
  rbind(
    c(12.39585, 51.31866),
    c(12.39846, 51.31722)
  ),
  crs = "EPSG:4326"
)
lines(l, col = "green", lw = 5)
idiv <- vect(
  rbind(
    c(12.39573, 51.31794),
    c(12.39645, 51.31765),
    c(12.39664, 51.31812),
    c(12.39602, 51.31849),
    c(12.39573, 51.31794)
  ),
  crs = "EPSG:4326"
) |>
  as.lines() |>
  as.polygons()
idiv$name <- "iDiv building"
idiv$perimeter <- perim(idiv)
idiv$area <- expanse(idiv)
plot(idiv, add = TRUE, col = adjustcolor("blue", alpha.f = .5))
```

Geometries are saved in _vector_ or _shape_ files.
In addition to the geometric representation of the structure, 
shapefiles also contain metadata for the geometric representation, 
such as the its extent and coordinate reference system (we will talk about this later),
and for the structure, such as their name, length, etc.
For instance, the geometry of the iDiv building above is:
```{r example-geometry, class.source="fold-hide", }
idiv
```

Note that this structure has one geometry and three attributes/variables (`dimensions : 1, 3 (geometries, attributes)`): `name`, `perimeter` ($m$), and `area` ($m^2$).

### Geometry Types

In `terra`, there are three main geometry types:

  1. Points: they are defined by a vector with two values for coordinates (e.g., longitude and latitude)
  2. Lines: they are a series of points connected pairwise by straight lines
  3. Polygons: they are a series of lines inscribing a closed area

In `terra`, geometries are created with the function `vect()`.
To create a point geometry, you need to pass a matrix with the coordinates:
```{r create-point}
xy <- cbind(12.39585, 51.31866)  # cbind force it to be a matrix
vect(xy)
```
To create a geometry of multiple points, simply pass a matrix that has multiple rows:
```{r create-points}
xy <- rbind(
  cbind(12.39585, 51.31866),
  cbind(12.39584, 51.31865)
)
poi <- vect(xy)
```

In order to create lines, first create a multi-point geometry, then convert it using `as.lines()`:
```{r create-lines}
xy <- rbind(
  cbind(12.39585, 51.31866),
  cbind(12.39584, 51.31865)
)
lin <- vect(xy) |> as.lines()
```

In order to create polygons, first create a mutli-point geometry, then covert it to lines, and finally to polygons using `as.polygons()`.
The last point should be the same as the first to close the geometry.

```{r create-polygons}
xy <- rbind(
  cbind(12.39585, 51.31866),
  cbind(12.39584, 51.31865),
  cbind(12.39584, 51.31866),
  cbind(12.39585, 51.31866)
)
pol <- vect(xy) |> as.lines() |> as.polygons()
```

```{r geometries-plot, fig.align='center'}
plot(pol, col = "gold")
lines(lin, col = "red", lw = 5)
points(poi, col = "blue", cex = 1)
```

### Reading & Writing Geometries
`vect()` is also used to read geometries from a file.
For instance, to read the shapefile with the country boundary of Germany:
```{r read-shapefile, fig.align='center'}
ger <- vect("data/germany.shp")
ger
```

To write geometries to disk, use `writeVector()`.

```{r, write-shapefile, eval=FALSE}
writeVector(ger, "data/germany.shp", overwrite = TRUE)
```

## Rasters {.tabset}

### Overview

Rasters are gridded areas where each grid pixel assumes a value.
When the data we are interested in are values on a gridded area, 
rasters are a better options than to using geometries.
For example, if we want to represent landcover type over a large area(forest, agriculture, build-up, etc.),
it is easier to grid the area into pixels and save the landcover type of each pixel rather
than to create a geometry for each different structure.
```{r leipzig-landcover, class.source="fold-hide", fig.align='center', fig.width=7, fig.caption="Landcover map of Leipzig from DLR (German Aerospace Center)"}
r <- rast("data/landcover-2015.tif")
plot(r)  # from EOC of DLR
```
Rasters are saved in raster files. 
In addition to the values of each grid, rasterfiles also contain metadata for the grid, 
such as the its extent and coordinate reference system (we will talk about this later).
For instance, some of the metadata of the landcover raster:
```{r raster-metadata, class.source="fold-hide"}
r
```
Note the metadata `dimensions` (grid size), `resolution` (spatial resolution, in $m$), 
and `extent` (spatial extent).

### Reading & Writing Rasters
To read rasters into memory, use `rast()`.
```{r read-raster, fig.align='center'}
r <- rast("data/landcover-2015.tif")
r
```

To write rasters to disk, use `writeRaster()`.

```{r, write-raster, eval=FALSE}
writeRaster(r, "data/landcover-2015.tif", overwrite = TRUE, datatype = "INT1U")
```
Here, the argument `datatype = "INTU1"` (specifying the values in the grid are 1-byte unsigned integers) 
is needed because the rasters contains classes (levels).
In most cases, this argument is best left unspecified, as `terra` picks the optimal value by default.

## Spatial metadata {.tabset}

Spatial objects, being geometries or rasters, always need certain metadata to be useful.
For example, a raster is of little help if there is not information of the area it covers.
The most important metadata are:

  1. Spatial extent: the four corners of the quadrilateral polygon that inscribe the object represented
  2. Coordinate reference system: how is the earth surface represented
  3. Resolution (for rasters only)

We will cover each one of these three metadata in detail.

### Spatial extent

### Coordinate reference system

To know the CRS of an object, use `crs()`.
By default, `crs()` displays the CRS in Well Known Text (WKT) format.
WKT is not very nice for humans; use the extra argument `proj = TRUE` to see the PROJ4
format of the CRS.

```{r, crs}
crs(idiv)
crs(idiv, proj = TRUE)
```

### Resolution

## Data Conversion

### Geometries to Rasters

```{r geom-to-rast}
idiv <- project(idiv, crs(r))
idiv_r <- rasterize(idiv, r, touches = TRUE)
plot(trim(idiv_r)); lines(idiv)
```

### Rasters to Geometries

```{r rast-to-geom}
r <- crop(r, buffer(idiv, 1e3))
p <- as.polygons(r)
plot(p, "category")
```
