[
  {
    "objectID": "labs/01-lab.html",
    "href": "labs/01-lab.html",
    "title": "Exercise 1",
    "section": "",
    "text": "We already modeled the niche and distribution of the species Podarcis muralis in the lecture Running our first ENM/SDM. We, however, tried only two sets of climatic predictors for this species. Here, your task is to re-run the two ENMs from that lecture and two more ENMs using different climatic variables. In particular, you should:\n\nRun 2 more ENMs.\nCheck their theoretical validity.\nCheck their statistical support.\nSelect the best ENM.\nUse that ENM for SDM (continuous and binary)."
  },
  {
    "objectID": "labs/01-lab.html#background",
    "href": "labs/01-lab.html#background",
    "title": "Exercise 1",
    "section": "",
    "text": "We already modeled the niche and distribution of the species Podarcis muralis in the lecture Running our first ENM/SDM. We, however, tried only two sets of climatic predictors for this species. Here, your task is to re-run the two ENMs from that lecture and two more ENMs using different climatic variables. In particular, you should:\n\nRun 2 more ENMs.\nCheck their theoretical validity.\nCheck their statistical support.\nSelect the best ENM.\nUse that ENM for SDM (continuous and binary)."
  },
  {
    "objectID": "labs/01-lab.html#set-up",
    "href": "labs/01-lab.html#set-up",
    "title": "Exercise 1",
    "section": "Set-up",
    "text": "Set-up\nTo set up the exercise, load all climatic layers and data for ENM/SDM.\n\n\nCode\nlibrary(terra)\n\n# load data frame for ENM\nd &lt;- read.csv(\"../data/occurrences.csv\")\n\n# load climate data for SDM\nff &lt;- list.files(\"../data\", pattern = \".tif\") # all files with .tif extension\nr &lt;- rast(file.path(\"..\", \"data\", ff))\nroi &lt;- ext(-13, 33, 33, 62) # roi of Europe\nr &lt;- crop(r, roi) # crop to Europe\n\n# ENM-1\nenm_01_12 &lt;- glm(\n  occ ~ poly(wc2.1_10m_bio_1, 2, raw = TRUE) + poly(wc2.1_10m_bio_12, 2, raw = TRUE),\n  data = d,\n  family = \"binomial\"\n)\n\n# ENM-2\nenm_06_14 &lt;- glm(\n  occ ~ poly(wc2.1_10m_bio_6, 2, raw = TRUE) + poly(wc2.1_10m_bio_14, 2, raw = TRUE),\n  data = d,\n  family = \"binomial\"\n)\n\n# Exercise starts from here\n# ..."
  },
  {
    "objectID": "labs/01-lab.html#solution",
    "href": "labs/01-lab.html#solution",
    "title": "Exercise 1",
    "section": "Solution",
    "text": "Solution\n\nRun 2 more ENMs\n\n\nCode\n# EMN-3 = only temperature variables\nenm_01_04 &lt;- glm(\n  occ ~ poly(wc2.1_10m_bio_1, 2, raw = TRUE) + poly(wc2.1_10m_bio_4, 2, raw = TRUE),\n  data = d,\n  family = \"binomial\"\n)\n\n# ENM-4 = only precipitation variables\nenm_12_15 &lt;- glm(\n  occ ~ poly(wc2.1_10m_bio_12, 2, raw = TRUE) + poly(wc2.1_10m_bio_14, 2, raw = TRUE),\n  data = d,\n  family = \"binomial\"\n)\n\n\n\n\nCheck theoretical validity\n\n\nCode\n# function for better code\ncheck_validity &lt;- function(enm) {\n  beta &lt;- coef(enm)\n  beta2 &lt;- beta[grepl(\")2\", names(beta))]\n  names(beta2) &lt;- gsub(\n    \"poly\\\\(|\\\\)2|, 2, raw = TRUE|wc2[.]1_10m_\",\n    \"\",\n    names(beta2)\n  )\n  beta2\n}\n\n# named list\nenms &lt;- list(\n  enm_01_12 = enm_01_12,\n  enm_06_14 = enm_06_14,\n  enm_01_04 = enm_01_04,\n  enm_12_15 = enm_12_15\n)\n\nlapply(enms, \\(x) check_validity(x)) # all valid\n\n\n$enm_01_12\n        bio_1        bio_12 \n-1.968334e-02 -4.775606e-06 \n\n$enm_06_14\n        bio_6        bio_14 \n-0.0149165983 -0.0005942085 \n\n$enm_01_04\n        bio_1         bio_4 \n-0.0328900575 -0.0001459555 \n\n$enm_12_15\n       bio_12        bio_14 \n-4.961380e-06 -7.325262e-05 \n\n\n\n\nCheck statistical support\n\n\nCode\n# AIC\naic &lt;- AIC(enm_01_12, enm_06_14, enm_01_04, enm_12_15)\n\n# order AIC\naic &lt;- aic[order(aic$AIC), ]\n\n# delta AIC\naic$deltaAIC &lt;- aic$AIC - min(aic$AIC)\n\naic # enm_01_04 is the best model\n\n\n          df      AIC deltaAIC\nenm_01_04  5 3605.657   0.0000\nenm_06_14  5 4026.429 420.7720\nenm_12_15  5 4098.389 492.7323\nenm_01_12  5 4281.717 676.0606\n\n\n\n\nSDM continuous\n\n\nCode\nsdm &lt;- predict(r, enm_01_04, type = \"response\")\nplot(sdm, col = hcl.colors(100, \"Spectral\", rev = TRUE))\n\n\n\n\n\n\n\n\n\n\n\n\n\nSDM binary\n\n\nCode\n# function for better code\ntss &lt;- function(suitability, observed, threshold) {\n  p &lt;- ifelse(suit &gt; threshold, 1, 0)\n  TP &lt;- sum(p == 1 & observed == 1)\n  FP &lt;- sum(p == 1 & observed == 0)\n  FN &lt;- sum(p == 0 & observed == 1)\n  TN &lt;- sum(p == 0 & observed == 0)\n  sens &lt;- TP / (TP + FN)\n  spec &lt;- TN / (TN + FP)\n  out &lt;- sens + spec - 1\n  return(out)\n}\n\n# suitability from SDM map\nsuit &lt;- extract(sdm, d[, c(\"x\", \"y\")], ID = FALSE)[, 1]\n\n# threshold gradient\nthreshold &lt;- seq(0.1, 0.9, by = 0.001)\n\nTSS &lt;- sapply(threshold, \\(th) tss(suit, d$occ, th))\n\n# best threshol\nth &lt;- threshold[which.max(TSS)]\n\n# binarize the continuous map\nsdm_bin &lt;- ifel(sdm &gt;= th, 1, 0)\nplot(sdm_bin, col = c(\"grey90\", \"dodgerblue\"))"
  },
  {
    "objectID": "lectures/03-data.html",
    "href": "lectures/03-data.html",
    "title": "Data for ENM/SDM",
    "section": "",
    "text": "Two types of data are required for ENM/SDM:"
  },
  {
    "objectID": "lectures/03-data.html#species-occurrence-data",
    "href": "lectures/03-data.html#species-occurrence-data",
    "title": "Data for ENM/SDM",
    "section": "Species occurrence data",
    "text": "Species occurrence data\nSpecies occurrence data record the occurrence of species geographically. The most known source of occurrence data are the Global Biodiversity Information Facility (GBIF) and iNaturalist.\n\n\n\n\n\n\nNote\n\n\n\nGBIF is a data aggregator, pulling data also from iNaturalist.\n\n\nOccurrence data usually record only the presence of species, i.e. the species was detected at that location, due to the absence of species being extremely difficult to record. However, because most ENMs require presence and absence data, absences are usually simulated assuming an underlying ecological process. We will cover this in more detail in the subsequent sections."
  },
  {
    "objectID": "lectures/03-data.html#environmental-data",
    "href": "lectures/03-data.html#environmental-data",
    "title": "Data for ENM/SDM",
    "section": "Environmental data",
    "text": "Environmental data\nENM/SDM usually investigate the effect of climatic variables on species distribution. Although other environmental covariates can be included, such as pH, landcover type, etc., this course focuses only on climatic variables, which are always accounted for in ENM/SDM. Climate is the probability density function of weather events, such as average, minimum, and maximum temperature (K) and precipitation (mm). Because many centers and research institutes model climate, climatic data can be accessed from a large variety of sources. In addition, bioclimatic variables are often derived from raw climate data and aggregated into long-term (e.g., 30 years) averages. These bioclimatic normals are often the climatic layers used in ENM/SDM. Some of the most used databases for bioclimatic normals are WorldClim, CHELSA, and PRISM.\n\n\n\n\n\n\nNote\n\n\n\nClimate data differ widely in how they are derived. They are not inter-changeable and often lead to different results."
  },
  {
    "objectID": "lectures/05-preparing-data.html",
    "href": "lectures/05-preparing-data.html",
    "title": "Preparing data for ENM/SDM",
    "section": "",
    "text": "We selected and downloaded the occurrence data for the species Podarcis muralis (Laurenti, 1768) from GBIF: https://doi.org/10.15468/dl.x74f4b. I specified already some filters in the query from GBIF, namely:\n\nThe coordinate uncertainty of the records must be \\(\\leq 5 km\\).\nThe year of the record must be \\(\\geq 1970\\) and \\(\\leq 2000\\).\n\nThe first filter removes records with high uncertainty, relatively to the spatial resolution of the climatic data we will use (ca. 12km). The second filter removes records outside the range of the climatic data we will use.\nWe load this data in R.\n\n\nCode\nlibrary(terra)\n\ngbif &lt;- read.csv(\"../data/0002051-260120142942310.csv\", sep = \"\\t\")\n\n\n\n\n\n\n\n\nNote\n\n\n\nsep = \"\\t\" specifies that the separator of the columns is a TAB, which is the standard used by GBIF.\n\n\nThis data frame has many columns that we do not need. We retain only the longitude and latitude columns and drop duplicate coordinates.\n\n\nCode\ngbif &lt;- gbif[, c(\"decimalLongitude\", \"decimalLatitude\")]\ngbif &lt;- unique(gbif)\n\n# load countries polygons\n# this is from rnaturalearth package, which is required by CoordinateCleaner\ncountry &lt;- vect(rnaturalearth::countries110)\n\n# plot gbif records\nplot(crop(country, gbif))\npoints(gbif, cex = .5, col = \"dodgerblue\")\n\n\n\n\n\n\n\n\n\nGBIF data is known to have inaccuracies and should always be checked for coordinate errors. For example, sometimes the reported coordinates are not where the species was found, but of the museum where the specimen is stored. The package CoordinateCleaner performs several quality checks on GBIF data and flags potential inaccuracies.\n\n\nCode\nlibrary(CoordinateCleaner)\n\nflags &lt;- clean_coordinates(\n  gbif,\n  species = NULL,\n  tests = c(\"capitals\", \"centroids\", \"equal\", \"gbif\", \"institutions\", \"seas\", \"zeros\")\n)\n\n\nThe data frame flags contains the column .summary with value TRUE if all tests did not find inaccuracies and FALSE if that data record failed at least one test. We use this to retain only GBIF records that have .summary = TRUE.\n\n\nCode\ngbif &lt;- gbif[flags$.summary, ]\n\nplot(crop(country, gbif))\npoints(gbif, cex = .5, col = \"dodgerblue\")\n\n\n\n\n\n\n\n\n\nThere are still points in the USA, which we want to remove manually.\n\n\n\n\n\n\nNote\n\n\n\nThe Wikipedia page of this species clarifies why there are detection in North America: It is referred to locally in the Cincinnati/Northern Kentucky area as the “Lazarus lizard”, as it was introduced to the area around 1950 by George Rau, a boy whose family owned the Lazarus department store chain (Lazarus has since been absorbed into Macy). After he returned from a family vacation to northern Italy, he released about 10 of the reptiles near his Cincinnati home.\n\n\n\n\nCode\ngbif &lt;- gbif[gbif$decimalLongitude &gt;= -20, ]\n\nplot(crop(country, gbif))\npoints(gbif, cex = .5, col = \"dodgerblue\")\n\n\n\n\n\n\n\n\n\nWe have now a data frame of cleaned occurrences from GBIF.\n\n\nTo be able to model the niche and the distribution of the species, we need also absences. We thus need to generate some pseudo-absences, i.e. simulated absences, and add them to the data frame. There are several ways to generate absences, but here we will focus only one one: randomly sampling the geographic area within the polygon inscribing all known occurrences. In doing so, however, we do not want to sample an absence in the same grid cell of a presence.\nThe code below show how to generate pseudo-absences following this approach.\n\n\nCode\n# data frame as SpatVector\ngbif &lt;- vect(\n  gbif,\n  geom = c(\"decimalLongitude\", \"decimalLatitude\"),\n  crs = \"EPSG:4326\"\n)\n\n# (convex) hull inscribing all known occurrences\nhull &lt;- convHull(gbif)\n\n# load one climate layer as template of the grid cell\ngrid &lt;- rast(\"../data/wc2.1_10m_bio_1.tif\") |&gt; crop(hull)\n\n# create a raster with \n# - 0 if there is a gbif record in that cell\n# - 1 if not\n# - NA for sea cells\nr &lt;- rasterize(gbif, grid, fun = \\(x) 0, background = 1)\nr[is.na(grid)] &lt;- NA\n\n# remove areas outside the polygon inscribing all GBIF records\nr &lt;- mask(r, hull)\n\n# sample absences\nabs &lt;- spatSample(\n  r,\n  length(gbif),       # n(abs) = n(pres)\n  as.points = TRUE,   # return a SpatVector\n  method = \"weights\", # trick to remove cells with a record (weight = r = 0)\n  values = FALSE      # we do not care about the values of the grid template\n)\n\n\nWe can now stitch the two SpatVector together.\n\n\nCode\ngbif$occ &lt;- 1 # presence\nabs$occ &lt;- 0  # absence\n\n# combine into one SpatVector\np &lt;- rbind(gbif, abs)\n\nplot(\n  p,\n  \"occ\",                           # color by `occ`\n  col = c(\"tomato\", \"dodgerblue\"), # color palette\n  cex = 0.3,\n  fun = \\() lines(country)         # outline of countries\n)\n\n\n\n\n\n\n\n\n\n\n\nWe can now use the SpatVector p to extract climatic variables."
  },
  {
    "objectID": "lectures/05-preparing-data.html#species-occurrence-data",
    "href": "lectures/05-preparing-data.html#species-occurrence-data",
    "title": "Preparing data for ENM/SDM",
    "section": "",
    "text": "We selected and downloaded the occurrence data for the species Podarcis muralis (Laurenti, 1768) from GBIF: https://doi.org/10.15468/dl.x74f4b. I specified already some filters in the query from GBIF, namely:\n\nThe coordinate uncertainty of the records must be \\(\\leq 5 km\\).\nThe year of the record must be \\(\\geq 1970\\) and \\(\\leq 2000\\).\n\nThe first filter removes records with high uncertainty, relatively to the spatial resolution of the climatic data we will use (ca. 12km). The second filter removes records outside the range of the climatic data we will use.\nWe load this data in R.\n\n\nCode\nlibrary(terra)\n\ngbif &lt;- read.csv(\"../data/0002051-260120142942310.csv\", sep = \"\\t\")\n\n\n\n\n\n\n\n\nNote\n\n\n\nsep = \"\\t\" specifies that the separator of the columns is a TAB, which is the standard used by GBIF.\n\n\nThis data frame has many columns that we do not need. We retain only the longitude and latitude columns and drop duplicate coordinates.\n\n\nCode\ngbif &lt;- gbif[, c(\"decimalLongitude\", \"decimalLatitude\")]\ngbif &lt;- unique(gbif)\n\n# load countries polygons\n# this is from rnaturalearth package, which is required by CoordinateCleaner\ncountry &lt;- vect(rnaturalearth::countries110)\n\n# plot gbif records\nplot(crop(country, gbif))\npoints(gbif, cex = .5, col = \"dodgerblue\")\n\n\n\n\n\n\n\n\n\nGBIF data is known to have inaccuracies and should always be checked for coordinate errors. For example, sometimes the reported coordinates are not where the species was found, but of the museum where the specimen is stored. The package CoordinateCleaner performs several quality checks on GBIF data and flags potential inaccuracies.\n\n\nCode\nlibrary(CoordinateCleaner)\n\nflags &lt;- clean_coordinates(\n  gbif,\n  species = NULL,\n  tests = c(\"capitals\", \"centroids\", \"equal\", \"gbif\", \"institutions\", \"seas\", \"zeros\")\n)\n\n\nThe data frame flags contains the column .summary with value TRUE if all tests did not find inaccuracies and FALSE if that data record failed at least one test. We use this to retain only GBIF records that have .summary = TRUE.\n\n\nCode\ngbif &lt;- gbif[flags$.summary, ]\n\nplot(crop(country, gbif))\npoints(gbif, cex = .5, col = \"dodgerblue\")\n\n\n\n\n\n\n\n\n\nThere are still points in the USA, which we want to remove manually.\n\n\n\n\n\n\nNote\n\n\n\nThe Wikipedia page of this species clarifies why there are detection in North America: It is referred to locally in the Cincinnati/Northern Kentucky area as the “Lazarus lizard”, as it was introduced to the area around 1950 by George Rau, a boy whose family owned the Lazarus department store chain (Lazarus has since been absorbed into Macy). After he returned from a family vacation to northern Italy, he released about 10 of the reptiles near his Cincinnati home.\n\n\n\n\nCode\ngbif &lt;- gbif[gbif$decimalLongitude &gt;= -20, ]\n\nplot(crop(country, gbif))\npoints(gbif, cex = .5, col = \"dodgerblue\")\n\n\n\n\n\n\n\n\n\nWe have now a data frame of cleaned occurrences from GBIF.\n\n\nTo be able to model the niche and the distribution of the species, we need also absences. We thus need to generate some pseudo-absences, i.e. simulated absences, and add them to the data frame. There are several ways to generate absences, but here we will focus only one one: randomly sampling the geographic area within the polygon inscribing all known occurrences. In doing so, however, we do not want to sample an absence in the same grid cell of a presence.\nThe code below show how to generate pseudo-absences following this approach.\n\n\nCode\n# data frame as SpatVector\ngbif &lt;- vect(\n  gbif,\n  geom = c(\"decimalLongitude\", \"decimalLatitude\"),\n  crs = \"EPSG:4326\"\n)\n\n# (convex) hull inscribing all known occurrences\nhull &lt;- convHull(gbif)\n\n# load one climate layer as template of the grid cell\ngrid &lt;- rast(\"../data/wc2.1_10m_bio_1.tif\") |&gt; crop(hull)\n\n# create a raster with \n# - 0 if there is a gbif record in that cell\n# - 1 if not\n# - NA for sea cells\nr &lt;- rasterize(gbif, grid, fun = \\(x) 0, background = 1)\nr[is.na(grid)] &lt;- NA\n\n# remove areas outside the polygon inscribing all GBIF records\nr &lt;- mask(r, hull)\n\n# sample absences\nabs &lt;- spatSample(\n  r,\n  length(gbif),       # n(abs) = n(pres)\n  as.points = TRUE,   # return a SpatVector\n  method = \"weights\", # trick to remove cells with a record (weight = r = 0)\n  values = FALSE      # we do not care about the values of the grid template\n)\n\n\nWe can now stitch the two SpatVector together.\n\n\nCode\ngbif$occ &lt;- 1 # presence\nabs$occ &lt;- 0  # absence\n\n# combine into one SpatVector\np &lt;- rbind(gbif, abs)\n\nplot(\n  p,\n  \"occ\",                           # color by `occ`\n  col = c(\"tomato\", \"dodgerblue\"), # color palette\n  cex = 0.3,\n  fun = \\() lines(country)         # outline of countries\n)\n\n\n\n\n\n\n\n\n\n\n\nWe can now use the SpatVector p to extract climatic variables."
  },
  {
    "objectID": "lectures/05-preparing-data.html#climate-data",
    "href": "lectures/05-preparing-data.html#climate-data",
    "title": "Preparing data for ENM/SDM",
    "section": "Climate data",
    "text": "Climate data\nIn this course, we always use the WorldClim bioclimatic variables to model the niche of species. Bioclimatic variables are derived from temperature and precipitation data and are considered to have the strongest influence on the distribution of species. A list of all of them can be found at https://www.worldclim.org/data/bioclim.html.\nLoad eight bioclimatic variables.\n\n\nCode\n# list of files of bioclimatic variables\nff &lt;- list.files(\n  \"../data\",         # where the files are\n  pattern = \"wc2.1\", # wc = WorldClim\n  full.names = TRUE  # full path\n)\n\n# load them into memory\nclimate &lt;- rast(ff)\nclimate\n\n\nclass       : SpatRaster \nsize        : 1080, 2160, 8  (nrow, ncol, nlyr)\nresolution  : 0.1666667, 0.1666667  (x, y)\nextent      : -180, 180, -90, 90  (xmin, xmax, ymin, ymax)\ncoord. ref. : lon/lat WGS 84 (EPSG:4326) \nsources     : wc2.1_10m_bio_1.tif  \n              wc2.1_10m_bio_12.tif  \n              wc2.1_10m_bio_13.tif  \n              ... and 5 more sources\nnames       : wc2.1~bio_1, wc2.1~io_12, wc2.1~io_13, wc2.1~io_14, wc2.1~io_15, wc2.1~bio_4, ... \nmin values  :   -54.72435,           0,           0,           0,      0.0000,       0.000, ... \nmax values  :    30.98764,       11191,        2381,         484,    229.0017,    2363.846, ... \n\n\nUsing p, we extract the values of the grid cells of climate for the occurrence data.\n\n\nCode\nd &lt;- extract(climate, p, ID = FALSE, cell = TRUE, xy = TRUE)\n\n\n\n\n\n\n\n\nTip\n\n\n\ncell = TRUE return also the ID of the cell of the raster where the records are found. This is useful to keep only one record per grid cell.\n\n\nWe assign the occurrence status (presence/absence) to this data frame.\n\n\nCode\nd$occ &lt;- p$occ\n\n\nThen, drop duplicate records, i.e. multiple records for the same grid cell.\n\n\nCode\n# drop rows with duplicated cells\nd &lt;- d[!duplicated(d$cell), ]\n\nhead(d)\n\n\n  wc2.1_10m_bio_1 wc2.1_10m_bio_12 wc2.1_10m_bio_13 wc2.1_10m_bio_14\n1       14.709969              510               60               20\n2       11.454646              775               89               44\n3        8.854438              933              106               60\n4       10.599990              633               61               44\n5       10.302510              632               58               45\n6        2.760979              549               68               27\n  wc2.1_10m_bio_15 wc2.1_10m_bio_4 wc2.1_10m_bio_5 wc2.1_10m_bio_6   cell occ\n1        25.683231        686.3660        32.04650         2.11375 620998   1\n2        21.440331        589.9808        25.82825        -0.33375 621014   1\n3        18.089415        578.0707        22.92975        -2.12900 618853   1\n4         9.118695        567.0883        23.99325         0.50650 538936   1\n5         8.751935        560.5479        23.76875         0.34775 534618   1\n6        30.307224        617.9191        15.89150        -8.37175 562745   1\n\n\nFinally, make sure to have more or less the same number of presences and absences.\n\n\nCode\ntable(d$occ) # not balanced\n\n\n\n   0    1 \n5016 1644 \n\n\nCode\nn &lt;- table(d$occ)[[\"1\"]]\nindex_pres &lt;- which(d$occ == 1)\nindex_abs &lt;- which(d$occ == 0)\n\n# subsample\nd &lt;- d[c(index_pres, sample(index_abs, n)), ]\n\ntable(d$occ) # balanced\n\n\n\n   0    1 \n1644 1644 \n\n\nCode\nwrite.csv(d, \"../data/occurrences.csv\", row.names = FALSE)\n\n\nWe have now a data frame obtained from GBIF that is ready to be used for ENM/SDM."
  },
  {
    "objectID": "lectures/02-theory.html",
    "href": "lectures/02-theory.html",
    "title": "Theory of ENM/SDM",
    "section": "",
    "text": "ENM relates one or more environmental variables, e.g. temperature and precipitation, to the suitability of species. The range and shape of how this suitability changes with the variables is called the environmental niche of the species. For example, the figure below shows the thermal niche of a species.\n\n\nCode\nl &lt;- function(x, mu, sigl, sigr) {\n  x[is.na(x)] &lt;- -9999\n  out &lt;- rep(NA, length(x))\n  out[x &lt; mu] &lt;- exp(- ((x[x &lt; mu] - mu) / sqrt(2) / sigl) ^ 2)\n  out[x &gt;= mu] &lt;- exp(- ((x[x &gt;= mu] - mu) / sqrt(2) / sigr) ^ 2)\n  out[x == -9999] &lt;- NA\n  return(out)\n}\nx &lt;- seq(0, 30, length.out = 1e3)\nplot(\n  x, l(x, 10, 3, 3),\n  type = \"l\", lwd = 2, col = \"dodgerblue3\",\n  xlab = \"Temperature\", \n  ylab = \"Suitability\"\n)\n\n\n\n\n\n\n\n\n\nTheory suggests that the niche must be convex, i.e. that the suitability between two points along an environmental gradient must be larger or equal to the value of the points. The curve shown above is an example of a convex niche. The niche is usually also not symmetrical, as biological processes are affected differently by extreme cold and heat. An example of a convex asymmetric niche is shown below.\n\n\nCode\nplot(\n  x, l(x, 10, 3, 1),\n  type = \"l\", lwd = 2, col = \"dodgerblue3\",\n  xlab = \"Temperature\", \n  ylab = \"Suitability\"\n)\n\n\n\n\n\n\n\n\n\nSpecies usually respond to more than one environmental covariate, making the niche multidimensional. An example of a non-symmetrical convex 2D niche is shown below.\n\n\nCode\n# actual niche\nmu &lt;- c(12, 800)\nsigl &lt;- c(3, 300)\nsigr &lt;- c(4, 500)\n\nx &lt;- seq(4, 22, length.out = 500)\ny &lt;- seq(0, 2000, length.out = 500)\nz &lt;- matrix(NA, nrow = length(y), ncol = length(x))\nfor (j in seq_along(x)) {\n  z[j, ] &lt;- l(x[j], mu[1], sigl[1], sigr[1]) * l(y, mu[2], sigl[2], sigr[2])\n}\nimage(\n  x, y, z,\n  xlab = \"Temperature\",\n  ylab = \"Precipitation\",\n  col = hcl.colors(100, \"Fall\", rev = TRUE)\n)\ncontour(\n  x, y, z,\n  add = TRUE,\n  levels = seq(0.1, 1, by = 0.2)\n)"
  },
  {
    "objectID": "lectures/02-theory.html#ecological-niche-modeling-enm",
    "href": "lectures/02-theory.html#ecological-niche-modeling-enm",
    "title": "Theory of ENM/SDM",
    "section": "",
    "text": "ENM relates one or more environmental variables, e.g. temperature and precipitation, to the suitability of species. The range and shape of how this suitability changes with the variables is called the environmental niche of the species. For example, the figure below shows the thermal niche of a species.\n\n\nCode\nl &lt;- function(x, mu, sigl, sigr) {\n  x[is.na(x)] &lt;- -9999\n  out &lt;- rep(NA, length(x))\n  out[x &lt; mu] &lt;- exp(- ((x[x &lt; mu] - mu) / sqrt(2) / sigl) ^ 2)\n  out[x &gt;= mu] &lt;- exp(- ((x[x &gt;= mu] - mu) / sqrt(2) / sigr) ^ 2)\n  out[x == -9999] &lt;- NA\n  return(out)\n}\nx &lt;- seq(0, 30, length.out = 1e3)\nplot(\n  x, l(x, 10, 3, 3),\n  type = \"l\", lwd = 2, col = \"dodgerblue3\",\n  xlab = \"Temperature\", \n  ylab = \"Suitability\"\n)\n\n\n\n\n\n\n\n\n\nTheory suggests that the niche must be convex, i.e. that the suitability between two points along an environmental gradient must be larger or equal to the value of the points. The curve shown above is an example of a convex niche. The niche is usually also not symmetrical, as biological processes are affected differently by extreme cold and heat. An example of a convex asymmetric niche is shown below.\n\n\nCode\nplot(\n  x, l(x, 10, 3, 1),\n  type = \"l\", lwd = 2, col = \"dodgerblue3\",\n  xlab = \"Temperature\", \n  ylab = \"Suitability\"\n)\n\n\n\n\n\n\n\n\n\nSpecies usually respond to more than one environmental covariate, making the niche multidimensional. An example of a non-symmetrical convex 2D niche is shown below.\n\n\nCode\n# actual niche\nmu &lt;- c(12, 800)\nsigl &lt;- c(3, 300)\nsigr &lt;- c(4, 500)\n\nx &lt;- seq(4, 22, length.out = 500)\ny &lt;- seq(0, 2000, length.out = 500)\nz &lt;- matrix(NA, nrow = length(y), ncol = length(x))\nfor (j in seq_along(x)) {\n  z[j, ] &lt;- l(x[j], mu[1], sigl[1], sigr[1]) * l(y, mu[2], sigl[2], sigr[2])\n}\nimage(\n  x, y, z,\n  xlab = \"Temperature\",\n  ylab = \"Precipitation\",\n  col = hcl.colors(100, \"Fall\", rev = TRUE)\n)\ncontour(\n  x, y, z,\n  add = TRUE,\n  levels = seq(0.1, 1, by = 0.2)\n)"
  },
  {
    "objectID": "lectures/02-theory.html#species-distribution-modeling-sdm",
    "href": "lectures/02-theory.html#species-distribution-modeling-sdm",
    "title": "Theory of ENM/SDM",
    "section": "Species Distribution Modeling (SDM)",
    "text": "Species Distribution Modeling (SDM)\nSDMs project ENMs from an environmental space to a geographical area. Its nuances are mainly in achieving this efficiently using GIS software and highlighting uncertainty of projections due to model extrapolation. For example, projecting the last 2D niche shown in this page onto Europe gives the projected suitability distribution shown below.\n\n\nCode\nlibrary(terra)\n\nroi &lt;- ext(-13, 33, 33, 62) # Europe\nr &lt;- rast(c(\"../data/wc2.1_10m_bio_1.tif\", \"../data/wc2.1_10m_bio_12.tif\")) |&gt; # load rasters\n  crop(roi) # crop to Europe\nw &lt;- r[[1]]\nw[!is.na(w)] &lt;- 1\nw &lt;- as.polygons(w)\n\nvals &lt;- values(r)\nl1 &lt;- l(vals[, 1], mu[1], sigl[1], sigr[1]) # first component of the niche\nl2 &lt;- l(vals[, 2], mu[2], sigl[2], sigr[2]) # second component of the niche\nsdm &lt;- r[[1]]\nnames(sdm) &lt;- \"\"\nvalues(sdm) &lt;- l1 * l2 # multiply two components\nplot(\n  sdm,\n  col = hcl.colors(100, \"Fall\", rev = TRUE),\n  fun = \\() lines(w),\n  axes = FALSE,\n  mar = c(2, 0, 1, 0)\n)\n\n\n\n\n\n\n\n\n\nGenerally speaking, the hard part of ENM/SDM is the ENM. Once the niche of inferred, projecting in geographic space is relatively trivial."
  },
  {
    "objectID": "lectures/02-theory.html#modeling-the-niche",
    "href": "lectures/02-theory.html#modeling-the-niche",
    "title": "Theory of ENM/SDM",
    "section": "Modeling the niche",
    "text": "Modeling the niche\nEcological Niche Modeling is a general term that applies to many types of models, all of which try to infer the niche of species. In this course, we will focus on two ENM frameworks, one relying on a generalized linear model (GLM) and one on the Random Forest (RF) algorithm (Breiman 2001). I chose GLM and RF because they represent two extremes of algorithms used in ENM, highlighting their different advantages and limitations. To explain these two procedures, I will use simulated data for a virtual species. The data for this species is stored in virtual.csv.\n\n\nCode\nd &lt;- read.csv(\"../data/virtual.csv\")\nhead(d)\n\n\n      BIO01 BIO12 occ\n1  9.987156   897   1\n2  9.333240   472   1\n3  9.853782   663   1\n4  7.313562  1025   1\n5  6.567688   689   1\n6 11.305479   807   1\n\n\nThis data frame has three columns. BIO01 and BIO12 are the average temperature and precipitation, respectively. occ is the occurrence status, namely if the species has been observed at that environmental conditions (1) or not (0).\n\nGLM\nThe simples GLM uses a quadratic curve and a binary (binomial) response. The quadratic curve assures the niche is convex, even though it does not allow asymmetric curves. In R, this is achieved using the following specifications.\n\n\nCode\nenm &lt;- glm(\n  occ ~ poly(BIO01, 2, raw = TRUE) + poly(BIO12, 2, raw = TRUE),\n  data = d,\n  family = binomial(\"logit\")\n)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThe syntax poly(x, n, raw = TRUE) is used in R to fit a polynomial of degree n to x. raw = TRUE makes sure the actual polynomial of x are used, and not a transformed version of them.\n\n\nWe can the plot this inferred niche on top of the actual niche.\n\n\nCode\nz_inferred &lt;- z\n\n# use `x` and `y` generated before\nfor (j in seq_along(x)) {\n  z_inferred[j, ] &lt;- predict(\n    enm, \n    newdata = data.frame(BIO01 = x[j], BIO12 = y),\n    type = \"response\"\n  )\n}\n\nimage(\n  x, y, z_inferred,\n  xlab = \"BIO01\",\n  ylab = \"BIO12\",\n  col = hcl.colors(100, \"Fall\", rev = TRUE)\n)\ncontour(\n  x, y, z,\n  add = TRUE,\n  levels = seq(0.1, 1, by = 0.2)\n)\n\n\n\n\n\n\n\n\n\nThe colors now show the inferred niche using glm() and the contours the actual niche. You can see that the actual niche is not symmetrical, but the inferred niche is. This is a common bias of GLM ENM. However, for its simplicity, a GLM ENM performs reasonably well at capturing the optimal environmental value and the general decline of suitability away from it.\n\n\nRandom Forest (RF)\nRF is a powerful machine-learning algorithm that has been applied to ENM for several decades. RF has its advantages, but has a major issue: the niche is rarely convex. In fact, in most cases, the niche will be concave (the opposite of convex). In R, RF is achieved using the package randomForest with the following specifications.\n\n\nCode\nlibrary(randomForest)\n\nenm &lt;- randomForest(\n  occ ~ BIO01 + BIO12,\n  data = d\n)\n\n\n\n\n\n\n\n\nNote\n\n\n\nThis throws a warning that can be silenced by specifying as.factor(occ), which makes randomForest() to consider a classification, rather than a regression, problem. However, we do not want this.\n\n\n\n\nCode\n# decrease a bit the resolution to speed it up\nx &lt;- seq(4, 22, length.out = 100)\ny &lt;- seq(0, 2000, length.out = 100)\nz &lt;- matrix(NA, nrow = length(y), ncol = length(x))\nz_inferred &lt;- matrix(0, nrow = length(y), ncol = length(x))\nfor (j in seq_along(x)) {\n  z[j, ] &lt;- l(x[j], mu[1], sigl[1], sigr[1]) * l(y, mu[2], sigl[2], sigr[2])\n  z_inferred[j, ] &lt;- predict(\n    enm, \n    newdata = data.frame(BIO01 = x[j], BIO12 = y),\n    type = \"response\"\n  )\n}\n\nimage(\n  x, y, z_inferred,\n  xlab = \"BIO01\",\n  ylab = \"BIO12\",\n  col = hcl.colors(100, \"Fall\", rev = TRUE)\n)\ncontour(\n  x, y, z,\n  add = TRUE,\n  levels = seq(0.1, 1, by = 0.2)\n)\n\n\n\n\n\n\n\n\n\nYou can see that the niche inferred by RF (colors) is very jagged. This is due to how RF works internally. We will not explain why this happens in this course, but we will highlight this feature of RF and discuss its implications several times. However, you can see that the predictions from the RF model follows, more or less, the shape of the actual niche (contour lines)."
  },
  {
    "objectID": "lectures/lectures.html",
    "href": "lectures/lectures.html",
    "title": "Lectures",
    "section": "",
    "text": "What are ENM/SDM and why do we use them?\n\n\n\n\n\n\n\n\n\n\nTheory of ENM/SDM\n\n\n\n\n\n\n\n\n\n\nData for ENM/SDM\n\n\n\n\n\n\n\n\n\n\nPreparing data for ENM/SDM\n\n\n\n\n\n\n\n\n\n\nRunning our first ENM/SDM\n\n\n\n\n\n\n\n\n\n\nGeographic and temporal extrapolation\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "lectures/06-first-sdm.html",
    "href": "lectures/06-first-sdm.html",
    "title": "Running our first ENM/SDM",
    "section": "",
    "text": "We can now model the ecological niche and the distribution of the species Podarcis muralis."
  },
  {
    "objectID": "lectures/06-first-sdm.html#species-niche-enm",
    "href": "lectures/06-first-sdm.html#species-niche-enm",
    "title": "Running our first ENM/SDM",
    "section": "Species niche (ENM)",
    "text": "Species niche (ENM)\nWe start by loading the species and climate data that we prepared in the previous section.\n\n\nCode\nd &lt;- read.csv(\"../data/occurrences.csv\")\nhead(d, n = 3)\n\n\n  wc2.1_10m_bio_1 wc2.1_10m_bio_12 wc2.1_10m_bio_13 wc2.1_10m_bio_14\n1       14.709969              510               60               20\n2       11.454646              775               89               44\n3        8.854438              933              106               60\n  wc2.1_10m_bio_15 wc2.1_10m_bio_4 wc2.1_10m_bio_5 wc2.1_10m_bio_6   cell\n1         25.68323        686.3660        32.04650         2.11375 620998\n2         21.44033        589.9808        25.82825        -0.33375 621014\n3         18.08941        578.0707        22.92975        -2.12900 618853\n           x        y occ\n1 -0.4166667 42.08333   1\n2  2.2500000 42.08333   1\n3  2.0833333 42.25000   1\n\n\nThe column names wc2.1_10m_bio_&lt;id&gt; means that this is data from WorldClim (wc) at a resolution of 10 arc-minutes (10m) for bioclimatic variables (&lt;id&gt;). Bioclimatic variables are generally highly correlated with each others and only a subset of them should be used for train an ecological niche model. Variable selection can be performed with the usual statistical tricks or, even better, can be informed by the biology of the species. Because I do not know the biology of the species, I build several competing ENMs and test which one is best using the Akaike information criterion (AIC).\nThe first model considers only average temperature (BIO01) and total precipitation (BIO12) to train an ENM using glm().\n\n\nCode\nenm_01_12 &lt;- glm(\n  occ ~ poly(wc2.1_10m_bio_1, 2, raw = TRUE) + poly(wc2.1_10m_bio_12, 2, raw = TRUE),\n  data = d,\n  family = \"binomial\"\n)\n\n\nWe can test how well these variables explain the distribution of the species by building another ENM with different variables and comparing it with the model above. For example, we can use the minimum temperature of the coldest month (BIO06) and the precipitation of the driest month (BIO14) instead.\n\n\nCode\nenm_06_14 &lt;- glm(\n  occ ~ poly(wc2.1_10m_bio_6, 2, raw = TRUE) + poly(wc2.1_10m_bio_14, 2, raw = TRUE),\n  data = d,\n  family = \"binomial\"\n)\n\n\nWe can compared the two models by AIC, with the best most having the lowest AIC.\n\n\nCode\nAIC(enm_01_12, enm_06_14)\n\n\n          df      AIC\nenm_01_12  5 4289.915\nenm_06_14  5 4030.867\n\n\nThe model with the second set of variables explain the distribution of the species better than the first model.\nLooking at AIC or other statistical metrics provides, however, only a measure of goodness of fit. Because we have clear assumptions backed by theory on how the shape of species niches should look like, we can see if the inferred niches by the two models fit our assumptions. Specifically, our assumption of concave-down niches requires that all quadratic coefficients are negative. We thus inspect the quadratic terms for both ENMs.\n\n\nCode\nmessage(\"ENM-1\")\nbeta_01_12 &lt;- coef(enm_01_12)\nbeta2_01_12 &lt;- beta_01_12[grepl(\")2\", names(beta_01_12))]\nnames(beta2_01_12) &lt;- gsub(\n  \"poly\\\\(|\\\\)2|, 2, raw = TRUE|wc2[.]1_10m_\",\n  \"\",\n  names(beta2_01_12)\n)\nbeta2_01_12\n\n\n        bio_1        bio_12 \n-1.779033e-02 -5.388666e-06 \n\n\nCode\nmessage(\"ENM-2\")\nbeta_06_14 &lt;- coef(enm_06_14)\nbeta2_06_14 &lt;- beta_06_14[grepl(\")2\", names(beta_06_14))]\nnames(beta2_06_14) &lt;- gsub(\n  \"poly\\\\(|\\\\)2|, 2, raw = TRUE|wc2[.]1_10m_\",\n  \"\",\n  names(beta2_06_14)\n)\nbeta2_06_14\n\n\n        bio_6        bio_14 \n-0.0115759369 -0.0006470727 \n\n\nSave the ENM as .rds object.\n\n\nCode\nsaveRDS(enm_06_14, \"../data/podarcis_muralis-enm.rds\")\n\n\nBecause of coefficients of ENM-2 are both negative, ENM-2 is both statistically supported and theoretically valid and we can use it for SDMs. Below is the inferred niche of ENM-2.\n\n\nCode\nnewd &lt;- expand.grid(\n  wc2.1_10m_bio_6 = seq(-20, 35, length.out = 3e2),\n  wc2.1_10m_bio_14 = seq(0, 200, length.out = 3e2)\n)\nz &lt;- predict(enm_06_14, newdata = newd, type = \"response\")\nz &lt;- matrix(\n  z,\n  nrow = length(unique(newd$wc2.1_10m_bio_6)),\n  ncol = length(unique(newd$wc2.1_10m_bio_14))\n)\nimage(\n  x = sort(unique(newd$wc2.1_10m_bio_6)),\n  y = sort(unique(newd$wc2.1_10m_bio_14)),\n  z = z,\n  col = hcl.colors(100, \"Spectral\", rev = TRUE),\n  xlab = \"BIO6\", ylab = \"BIO14\"\n)"
  },
  {
    "objectID": "lectures/06-first-sdm.html#species-distribution-sdm",
    "href": "lectures/06-first-sdm.html#species-distribution-sdm",
    "title": "Running our first ENM/SDM",
    "section": "Species distribution (SDM)",
    "text": "Species distribution (SDM)\nWhen using glm(), terra makes it extremely easy to produce a SDM. We first need to load the raster layers of the bioclimatic variables.\n\n\nCode\nlibrary(terra)\n\nff &lt;- list.files(\"../data\", pattern = \".tif\") # all files with .tif extension\nr &lt;- rast(file.path(\"..\", \"data\", ff))\nroi &lt;- ext(-13, 33, 33, 62) # roi of Europe\nr &lt;- crop(r, roi) # crop to Europe\n\n\nThe terra function predict(&lt;raster&gt;, model) is all we need.\n\n\nCode\nsdm &lt;- predict(r, enm_06_14, type = \"response\")\nplot(sdm, col = hcl.colors(100, \"Spectral\", rev = TRUE))\n\n\n\n\n\n\n\n\n\n\n\n\nBinary projections\nAnd we obtained the projected suitability of the species for Europe. Note that this is a continuous value, in this case representing the probability of detecting the species given climate. If we are interested in a binary map, e.g. showing the climatic range of the species, we need to binarize this continuous value into 0/1. There are several approaches to achieve this, but here we consider only the approach using the true skill statistics (TSS), which is one of the most widely used.\nThe main idea of the TSS approach is to pick a threshold value and set the cells of the map above to 0 if their values if less than this threshold and to 1 otherwise. These 0/1 values are then compared to the known occurrence of the species to calculate\n\nThe number of occurrences correctly predicted as presences (true positives, TP).\nThe number of occurrences incorrectly predicted as absences (false negatives, FN).\nThe number of occurrences correctly as absences (true negatives, TN).\nThe number of occurrences incorrectly presences (false positives, FP).\n\nTSS is defined as \\(TSS = \\frac{TP\\,TN - FP\\,FN}{(TP+FN)(TN+FP)}\\), which is a statistic balancing how well the model performs in predicting both presences and absences. TSS ranges from 0, for a model not better than random, to 1, for a model with perfect predictions.\nIf we pick several threshold and calculate the TSS for each of them, the best threshold is the one that has highest TSS, which is also the TSS of our model predictions.\n\n\nCode\n# extract the values from the continuous map\nsuit &lt;- extract(sdm, d[, c(\"x\", \"y\")], ID = FALSE)[, 1]\n\n# generate a gradient of threshold values\nthreshold &lt;- seq(0.1, 0.9, by = 0.001)\ntss &lt;- rep(NA, length(threshold)) # empty vector for storage\n\n# iterate over threshold values\nfor (i in seq_along(threshold)) {\n  p &lt;- ifelse(suit &gt; threshold[i], 1, 0)\n  TP &lt;- sum(p == 1 & d$occ == 1)\n  FP &lt;- sum(p == 1 & d$occ == 0)\n  FN &lt;- sum(p == 0 & d$occ == 1)\n  TN &lt;- sum(p == 0 & d$occ == 0)\n  sens &lt;- TP / (TP + FN)\n  spec &lt;- TN / (TN + FP)\n  tss[i] &lt;- sens + spec - 1\n}\n\nth &lt;- threshold[which.max(tss)] # best threshold\n\nplot(\n  threshold, tss,\n  type = \"l\", \n  main = paste0(\"Highest TSS = \", round(max(tss), 2), \"\\nTreshold = \", round(th, 2)),\n  xlab = \"Threshold value\", ylab = \"TSS\"\n)\nabline(v = th, lty = 2)\n\n# binarize the continuous map\nsdm_bin &lt;- ifel(sdm &gt;= th, 1, 0)\nplot(sdm_bin, col = c(\"grey90\", \"dodgerblue\"))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThis binary map is quite incorrect for this species. According to the IUCN (https://www.iucnredlist.org/species/61550/12514105), this species is found also in most of Italy, all the Balkans, and part of Turkey, but is not found in the UK, the Low Countries, and most of Germany. Why do we get such bad projections compared to the known range from IUCN? We will answer this in a next lecture, but my general recommendation is to plot the detection points.\n\n\nCode\nplot(sdm_bin, col = c(\"grey90\", \"dodgerblue\"))\npoints(d[d$occ == 1, c(\"x\", \"y\")], pch = 20, cex = .3)\n\n\n\n\n\n\n\n\n\n\n\nThe selected detection records are geographically biased and likely the environmental (climatic) space is not well represented."
  },
  {
    "objectID": "lectures/01-background.html",
    "href": "lectures/01-background.html",
    "title": "What are ENM/SDM and why do we use them?",
    "section": "",
    "text": "The goal of Ecological Niche Modeling (ENM) is to infer the ecological niche of species. A typical set of questions that ENM tries to answer is:\n\nWhat is the optimal temperature for this species?\nWhat is the range of temperature that this species can tolerate?\nWhat is the minimum level of precipitation that this species need to survive?\nIs this species limited by temperature of precipitation?\n\nENM works entirely in environmental space. Species Distribution Modeling (SDM) is the projection of a ENM into geographical space. The workflow of SDM is always to first perform an ENM and then to use this to achieve a SDM.\nThe applications of ENM/SDM are varied. Insights from ENM when employed alone (i.e. without an SDM) are useful mostly for academic and research purposes. In addition to these, SDM have conservation applications. For instance, SDM can project future biodiversity changes (Sinclair, White, and Newell 2010), highlight species particularly sensitive to future climate changes (Zurell et al. 2023), and help designing protected areas and guide policy making (Villero et al. 2017)."
  },
  {
    "objectID": "lectures/01-background.html#background",
    "href": "lectures/01-background.html#background",
    "title": "What are ENM/SDM and why do we use them?",
    "section": "",
    "text": "The goal of Ecological Niche Modeling (ENM) is to infer the ecological niche of species. A typical set of questions that ENM tries to answer is:\n\nWhat is the optimal temperature for this species?\nWhat is the range of temperature that this species can tolerate?\nWhat is the minimum level of precipitation that this species need to survive?\nIs this species limited by temperature of precipitation?\n\nENM works entirely in environmental space. Species Distribution Modeling (SDM) is the projection of a ENM into geographical space. The workflow of SDM is always to first perform an ENM and then to use this to achieve a SDM.\nThe applications of ENM/SDM are varied. Insights from ENM when employed alone (i.e. without an SDM) are useful mostly for academic and research purposes. In addition to these, SDM have conservation applications. For instance, SDM can project future biodiversity changes (Sinclair, White, and Newell 2010), highlight species particularly sensitive to future climate changes (Zurell et al. 2023), and help designing protected areas and guide policy making (Villero et al. 2017)."
  },
  {
    "objectID": "labs/labs.html",
    "href": "labs/labs.html",
    "title": "Labs",
    "section": "",
    "text": "Exercise 1\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Species Distribution Models",
    "section": "",
    "text": "This course introduces Ecological Niche Modeling (ENM) and Species Distribution Modeling (SDM) using the R programming language.\n\n\n\n\n\n\nImportant\n\n\n\nThis course assumes basic R knowledge.\n\n\nIn the first # days, etc.\n\n\n\n\n\n\nNote\n\n\n\nA basic knowledge of Geographic Information Systems is required for ENM/SDM. I will introduce basic concepts and operations of of GIS, but this is not a course about GIS.\nI give a course at iDiv that you can access here. SFU Jena also offers GIS courses: MSc Environmental and Georesources Management, MSc Geoinformatic, and BSc Geography."
  },
  {
    "objectID": "index.html#course-overview",
    "href": "index.html#course-overview",
    "title": "Species Distribution Models",
    "section": "",
    "text": "This course introduces Ecological Niche Modeling (ENM) and Species Distribution Modeling (SDM) using the R programming language.\n\n\n\n\n\n\nImportant\n\n\n\nThis course assumes basic R knowledge.\n\n\nIn the first # days, etc.\n\n\n\n\n\n\nNote\n\n\n\nA basic knowledge of Geographic Information Systems is required for ENM/SDM. I will introduce basic concepts and operations of of GIS, but this is not a course about GIS.\nI give a course at iDiv that you can access here. SFU Jena also offers GIS courses: MSc Environmental and Georesources Management, MSc Geoinformatic, and BSc Geography."
  },
  {
    "objectID": "index.html#learning-objectives",
    "href": "index.html#learning-objectives",
    "title": "Species Distribution Models",
    "section": "Learning objectives",
    "text": "Learning objectives\n\nUnderstand the theory behind ENM/SDM.\nPerform ENM/SDM in R.\nApply ENM/SDM to real data.\nProduce maps."
  },
  {
    "objectID": "index.html#software",
    "href": "index.html#software",
    "title": "Species Distribution Models",
    "section": "Software",
    "text": "Software\nThe only package that we will use is terra. You might want to install also codetools, which performs checks on the C++ code of terra.\n\ninstall.packages(c(\"codetools\", \"terra\"))\n\n\n\n\n\n\n\nNote\n\n\n\nterra is still in active development and some functionalities change with newer releases."
  },
  {
    "objectID": "slides/slides.html",
    "href": "slides/slides.html",
    "title": "Slides",
    "section": "",
    "text": "Below are all the lecture slides. Click to open each one:\n\nIntroduction.\n\n\n\nTheory.\nEcological Niche Modeling with GLM.\nEcological Niche Modeling with Random Forest.\n\n\n\nPreparing data for ENM/SDM\nRunning the first ENM/SDM"
  },
  {
    "objectID": "lectures/07-extrapolations.html",
    "href": "lectures/07-extrapolations.html",
    "title": "Geographic and temporal extrapolation",
    "section": "",
    "text": "The ENM for the species Podarcis muralis from the previous lecture is trained on data obtained from Europe.\nCode\nlibrary(terra)\n\n# load ENM\nenm &lt;- readRDS(\"../data/podarcis_muralis-enm.rds\")\nOne might be interested in projecting the potential distribution of this species outside the range of the training locations. This procedure is called geographical extrapolation. For example, we might want to extrapolated the ENM to North America, where an invasive population was established after a boy brought this species back from a trip to Italy. In addition, one might be interested in projecting the distribution for future climate conditions. This procedure is called temporal extrapolation. For example, we might want to assess where the species will go extinct and where it will expand in the future. Although both types of extrapolations are practically performed in the same way, they have slightly different assumptions."
  },
  {
    "objectID": "lectures/07-extrapolations.html#geographic-extrapolation",
    "href": "lectures/07-extrapolations.html#geographic-extrapolation",
    "title": "Geographic and temporal extrapolation",
    "section": "Geographic extrapolation",
    "text": "Geographic extrapolation\nGeographic extrapolations are achieved simply by projecting to a new raster layer with the same type of data used for training the ENM. For example, we can project the distribution of P. muralis in North America.\n\n\nCode\n# load bioclims\nr &lt;- rast(file.path(\"../data\", c(\"wc2.1_10m_bio_6.tif\", \"wc2.1_10m_bio_14.tif\")))\ne &lt;- ext(-105, -65, 24, 45)  # North America\nr &lt;- crop(r, e)\n\n\nFor the GLM ENM, use the terra::predict() functions.\n\n\nCode\nsdm &lt;- predict(r, enm, type = \"response\")\nsdm_bin &lt;- ifel(sdm &gt;= 0.55, 1, 0) # from previous lecture\nplot(sdm, col = hcl.colors(100, \"Spectral\", rev = TRUE))\nplot(sdm_bin, col = c(\"#00000080\", \"#FFFFFF00\"), add = TRUE)\n\n\n\n\n\n\n\n\n\nThis map show both the continous SDM (colors) and the binary SDM (black shade masks the areas outside the projected suitabile range).\nIf the climate layers are not cropped, the projection will be worldwide.\n\n\nCode\n# re-load bioclims\nr &lt;- rast(file.path(\"../data\", c(\"wc2.1_10m_bio_6.tif\", \"wc2.1_10m_bio_14.tif\")))\n\n# re-project SDM\nsdm &lt;- predict(r, enm, type = \"response\")\nsdm_bin &lt;- ifel(sdm &gt;= 0.55, 1, 0) # from previous lecture\nplot(sdm, col = hcl.colors(100, \"Spectral\", rev = TRUE))\nplot(sdm_bin, col = c(\"#00000080\", \"#FFFFFF00\"), add = TRUE)\n\n\n\n\n\n\n\n\n\nGeographic extrapolations have one potential issue: The environmental (climatic) conditions in the extrapolated area might be outside the range of the data used for training.\nThe easiest way to understand potential issues due to this statistical extrapolation is to visualize again the inferred niche of the species.\n\n\nCode\nnewd &lt;- expand.grid(\n  wc2.1_10m_bio_6 = seq(-20, 35, length.out = 3e2),\n  wc2.1_10m_bio_14 = seq(0, 200, length.out = 3e2)\n)\nz &lt;- predict(enm, newdata = newd, type = \"response\")\nz &lt;- matrix(\n  z,\n  nrow = length(unique(newd$wc2.1_10m_bio_6)),\n  ncol = length(unique(newd$wc2.1_10m_bio_14))\n)\nimage(\n  x = sort(unique(newd$wc2.1_10m_bio_6)),\n  y = sort(unique(newd$wc2.1_10m_bio_14)),\n  z = z,\n  col = hcl.colors(100, \"Spectral\", rev = TRUE),\n  xlab = \"BIO6\", ylab = \"BIO14\"\n)\n\n\n\n\n\n\n\n\n\nIf we overlay on this image a mask highlighting the range of the training data, i.e. the range of the climatic variables at locations where the species was detected, we notice a subtle problem.\n\n\nCode\n# load occurrence data\nd &lt;- read.csv(\"../data/occurrences.csv\")\nranges &lt;- apply(d[, c(\"wc2.1_10m_bio_6\", \"wc2.1_10m_bio_14\")], MARGIN = 2, range)\nimage(\n  x = sort(unique(newd$wc2.1_10m_bio_6)),\n  y = sort(unique(newd$wc2.1_10m_bio_14)),\n  z = z,\n  col = hcl.colors(100, \"Spectral\", rev = TRUE),\n  xlab = \"BIO6\", ylab = \"BIO14\"\n)\nrect(\n  xleft = -30,\n  ybottom = 0,\n  xright = ranges[1, 1],\n  ytop = 200,\n  col = \"#00000080\",\n  lwd = 0\n)\nrect(\n  xleft = ranges[2, 1],\n  ybottom = 0,\n  xright = 50,\n  ytop = 200,\n  col = \"#00000080\",\n  lwd = 0\n)\nrect(\n  xleft = ranges[1, 1],\n  ybottom = 0,\n  xright = ranges[2, 1],\n  ytop = ranges[1, 2],\n  col = \"#00000080\",\n  lwd = 0\n)\nrect(\n  xleft = ranges[1, 1],\n  ybottom = ranges[2, 2],\n  xright = ranges[2, 1],\n  ytop = 300,\n  col = \"#00000080\",\n  lwd = 0\n)\n\n\n\n\n\n\n\n\n\nThe black shades show where the occurrence data did not have any climatic data, i.e. regions of the environmental (climatic) space that were not explored and did not contribute in training our ENM. When we extrapolate outside of this training box, e.g. for values of BIO6 &gt; 10 or of BIO14 &gt; 120, the validity of our ENM is questionable and our projections become very uncertain. How much questionable and uncertain depends on the algorithm used for ENM and how far away extrapolations are from the training range."
  }
]